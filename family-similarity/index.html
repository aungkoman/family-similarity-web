<!DOCTYPE html>
<!--
  Family Similarity Demo
  ---------------------------------
  This single-file web app uses face-api.js (TensorFlow.js models) to:
  - Load a family photo
  - Detect faces and extract thumbnails
  - Let the user tag Baby, Mom, and Dad directly on each face card
  - Compute similarity (cosine) between Baby↔Mom and Baby↔Dad

  Key concepts to learn:
  - Web page structure: semantic HTML with a sidebar panel
  - Styling: modern CSS variables and a simple grid layout
  - Face detection pipeline: face-api.js model loading, detection, resizing
  - UX: thumbnails and per-face dropdowns for role tagging
  - Math: cosine similarity and basic validation of inputs
-->
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Family Similarity</title>
  <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
  <style>
    /* CSS Overview: variables (theme), layout grid, panel and card styling */
    :root {
      --bg: #0b0f14;
      --fg: #e6e6e6;
      --muted: #94a3b8;
      --accent: #4cc9f0;
      --card: #111827;
      --border: #1f2937;
    }
    * { box-sizing: border-box; }
    body { margin: 0; background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header, main { max-width: 1100px; margin: 0 auto; padding: 16px; }
    h1 { margin: 8px 0 12px; font-size: 22px; }
    #uploader { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    #uploader input[type="file"], button, select { background: #0f172a; color: var(--fg); border: 1px solid var(--border); border-radius: 8px; padding: 8px 10px; }
    /* Stack preview and panel vertically */
    #workspace { position: relative; display: grid; grid-template-columns: 1fr; gap: 16px; margin-top: 12px; }
    #imageContainer { position: relative; }
    #canvas { position: absolute; top: 0; left: 0; pointer-events: none; }
    #imageContainer img { max-width: 100%; height: auto; display: block; }
    #panel { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 12px; }
    #facesList { display: grid; gap: 8px; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
    .faceItem { display: flex; flex-direction: column; gap: 8px; align-items: center; border-bottom: 1px dashed #1e293b; padding-bottom: 8px; }
    .faceItem:last-child { border-bottom: none; }
    .thumb { width: 56px; height: 56px; border-radius: 8px; border: 1px solid var(--border); background: #0f172a; overflow: hidden; }
    .thumb img { width: 100%; height: 100%; object-fit: contain; display: block; }
    .row { display: flex; flex-direction: column; gap: 6px; align-items: stretch; }
    .meta { font-size: 12px; color: var(--muted); }
    #result { margin-top: 10px; font-weight: 600; }
  </style>
</head>
<body>
  <header role="banner">
    <!-- Top area: uploader and clear action -->
    <h1>Family Similarity</h1>
    <div id="uploader" role="group" aria-label="Upload family photo">
      <input type="file" id="imageUpload" accept="image/*" aria-label="Choose a family photo" />
      <button id="clearBtn" aria-label="Clear photo and detections">Clear</button>
    </div>
  </header>
  <main role="main">
    <div id="workspace">
      <!-- Left: photo + detection overlay canvas -->
      <div id="imageContainer">
        <img id="photo" alt="Uploaded family photo" />
        <canvas id="canvas" aria-label="Detections overlay"></canvas>
      </div>
      <aside id="panel" aria-label="Face tagging and similarity">
        <div class="row">
          <strong>Tag Family Members</strong>
        </div>
        <div id="facesList" aria-live="polite"></div>
        <!-- Button to compute similarity between assigned roles -->
        <button id="calcBtn" aria-label="Calculate similarity">Calculate Similarity</button>
        <div id="result" aria-live="polite"></div>
      </aside>
    </div>
  </main>

  <script>
    const imageUpload = document.getElementById('imageUpload'); // file input
    const clearBtn = document.getElementById('clearBtn');
    const canvas = document.getElementById('canvas');
    const photo = document.getElementById('photo');
    const facesList = document.getElementById('facesList');
    const resultDiv = document.getElementById('result');
    const calcBtn = document.getElementById('calcBtn');
    const MODEL_URL = 'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights';

    let faces = []; // per-face: { descriptor, box, canvas }
    let rolesMap = { baby: null, mom: null, dad: null }; // assigned roles by face index

    // Load models required for detection + recognition
    Promise.all([
      faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL),
      faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),
      faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL)
    ]).then(() => {
      resultDiv.innerText = 'Models loaded. Upload a family photo.';
      start();
    }).catch(err => {
      console.error(err);
      resultDiv.innerText = 'Failed to load face models. Please check your internet connection.';
    });

    function start() {
      // Handle image selection to run face detection pipeline
      imageUpload.addEventListener('change', async () => {
        if (!imageUpload.files || !imageUpload.files[0]) {
          resultDiv.innerText = 'Please choose an image file.';
          return;
        }
        resultDiv.innerText = 'Detecting faces...';
        faces = [];

        const img = await faceapi.bufferToImage(imageUpload.files[0]);
        photo.src = img.src;
        await photo.decode();
        // Ensure layout has applied before measuring client size
        await new Promise(resolve => requestAnimationFrame(resolve));
        const displaySize = { width: photo.clientWidth, height: photo.clientHeight };
        canvas.width = displaySize.width;
        canvas.height = displaySize.height;
        const ctx = canvas.getContext('2d');

        const detections = await faceapi
          .detectAllFaces(photo, new faceapi.SsdMobilenetv1Options({ minConfidence: 0.5 }))
          .withFaceLandmarks()
          .withFaceDescriptors();

        if (!detections.length) {
          resultDiv.innerText = 'No faces detected. Try a clearer photo.';
          return;
        }

        // Draw boxes with index labels on overlay canvas
        ctx.clearRect(0,0,canvas.width, canvas.height);
        faceapi.matchDimensions(canvas, displaySize);
        const resized = faceapi.resizeResults(detections, displaySize);
        resized.forEach((det, idx) => {
          const { x, y, width, height } = det.detection.box;
          ctx.strokeStyle = '#4cc9f0';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, width, height);
          ctx.fillStyle = 'rgba(76,201,240,0.8)';
          ctx.font = '14px system-ui';
          ctx.fillText(`#${idx+1}`, x + 4, y + 16);
        });

        // Extract per-face thumbnails for UI (padded to show full face)
        const natW = photo.naturalWidth || photo.width;
        const natH = photo.naturalHeight || photo.height;
        const padXRatio = 0.2; // add horizontal margin around detection
        const padYRatio = 0.3; // add vertical margin to include hair/chin
        const thumbSize = 112; // render high-res thumbnails, downscaled in CSS

        const extracted = detections.map(det => {
          const b = det.detection.box; // detection in natural image coordinates
          const padX = b.width * padXRatio;
          const padY = b.height * padYRatio;
          // initial padded rectangle
          let sx = Math.max(0, Math.floor(b.x - padX));
          let sy = Math.max(0, Math.floor(b.y - padY));
          let sWidth = Math.min(natW - sx, Math.floor(b.width + 2 * padX));
          let sHeight = Math.min(natH - sy, Math.floor(b.height + 2 * padY));
          // make square region centered on face for consistent thumbnails
          const side = Math.max(sWidth, sHeight);
          sx = Math.max(0, Math.floor((b.x + b.width / 2) - side / 2));
          sy = Math.max(0, Math.floor((b.y + b.height / 2) - side / 2));
          sWidth = Math.min(natW - sx, side);
          sHeight = Math.min(natH - sy, side);

          const t = document.createElement('canvas');
          t.width = thumbSize;
          t.height = thumbSize;
          const tctx = t.getContext('2d');
          tctx.imageSmoothingEnabled = true;
          tctx.imageSmoothingQuality = 'high';
          tctx.drawImage(photo, sx, sy, sWidth, sHeight, 0, 0, thumbSize, thumbSize);
          return t;
        });
        faces = detections.map((r, i) => ({ descriptor: r.descriptor, box: r.detection.box, canvas: extracted[i] }));
        rolesMap = { baby: null, mom: null, dad: null };
        if (faces.length >= 3) rolesMap = { baby: 0, mom: 1, dad: 2 };

        populateFacesUI();
        resultDiv.innerText = 'Assign roles using dropdowns, then Calculate.';
      });

      clearBtn.addEventListener('click', () => {
        photo.src = '';
        faces = [];
        facesList.innerHTML = '';
        resultDiv.innerText = '';
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,canvas.width, canvas.height);
      });
    }

    function populateFacesUI() {
      // Build cards (thumbnail + role dropdown) for each detected face
      facesList.innerHTML = '';
      faces.forEach((f, i) => {
        const item = document.createElement('div');
        item.className = 'faceItem';
        const thumb = document.createElement('div'); thumb.className = 'thumb';
        if (f.canvas) {
          const imgFace = new Image();
          imgFace.src = f.canvas.toDataURL();
          imgFace.alt = `Face #${i+1}`;
          thumb.appendChild(imgFace);
        }
        const meta = document.createElement('div');
        meta.innerHTML = `<div class="row"><strong>Face #${i+1}</strong>
          <select class="roleSel" aria-label="Assign role">
            <option value="none">Unassigned</option>
            <option value="baby">Baby</option>
            <option value="mom">Mom</option>
            <option value="dad">Dad</option>
          </select>
        </div>
        <div class="meta">Assign role using this dropdown, then Calculate.</div>`;
        item.appendChild(thumb); item.appendChild(meta);
        facesList.appendChild(item);

        const roleSel = meta.querySelector('.roleSel'); // dropdown for assigning role
        if (rolesMap.baby === i) roleSel.value = 'baby';
        else if (rolesMap.mom === i) roleSel.value = 'mom';
        else if (rolesMap.dad === i) roleSel.value = 'dad';
        else roleSel.value = 'none';
        roleSel.addEventListener('change', () => assignRole(roleSel.value, i));
      });
    }

    function assignRole(role, index) {
      // Ensure each role is unique and each face holds at most one role
      // clear roles currently assigned to this face index
      for (const r of ['baby','mom','dad']) {
        if (rolesMap[r] === index) rolesMap[r] = null;
      }
      if (role !== 'none') {
        // if another face holds the role, overwrite
        for (const r of ['baby','mom','dad']) {
          if (r === role) continue;
        }
        rolesMap[role] = index;
      }
      // ensure uniqueness across roles
      const seen = new Set();
      for (const r of ['baby','mom','dad']) {
        const v = rolesMap[r];
        if (v === null) continue;
        if (seen.has(v)) rolesMap[r] = null; else seen.add(v);
      }
      populateFacesUI();
    }

    function cosineSim(a, b) {
      // Cosine similarity: (a·b)/(||a||*||b||)
      let dot = 0, normA = 0, normB = 0;
      for (let i = 0; i < a.length; i++) {
        dot += a[i] * b[i];
        normA += a[i] * a[i];
        normB += b[i] * b[i];
      }
      return dot / (Math.sqrt(normA) * Math.sqrt(normB));
    }

    calcBtn.addEventListener('click', () => {
      // Validate roles and compute similarity percentages
      if (!faces.length) { resultDiv.innerText = 'Upload a photo first.'; return; }
      const bi = rolesMap.baby, mi = rolesMap.mom, di = rolesMap.dad;
      if (bi === null || mi === null || di === null) {
        resultDiv.innerText = 'Assign Baby, Mom, and Dad using the dropdowns.';
        return;
      }
      if (new Set([bi, mi, di]).size < 3) {
        resultDiv.innerText = 'Baby, Mom, and Dad must be different faces.';
        return;
      }
      const baby = faces[bi].descriptor;
      const mom = faces[mi].descriptor;
      const dad = faces[di].descriptor;
      const simMom = cosineSim(baby, mom);
      const simDad = cosineSim(baby, dad);
      const pctMom = Math.round(Math.max(0, Math.min(1, simMom)) * 10000) / 100; // 2 decimals
      const pctDad = Math.round(Math.max(0, Math.min(1, simDad)) * 10000) / 100;
      const more = simMom > simDad ? 'Mom' : 'Dad';
      const pct = simMom > simDad ? pctMom : pctDad;
      resultDiv.innerText = `Baby looks more like ${more} (Similarity: ${pct}%) — Mom: ${pctMom}%, Dad: ${pctDad}%`;
    });
  </script>
</body>
</html>
