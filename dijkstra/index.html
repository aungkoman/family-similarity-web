<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Myanmar City Shortest Path (Dijkstra)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #controls {
      background: #f8f9fa;
      padding: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    #map {
      flex: 1;
    }
    select, button {
      padding: 6px 10px;
      margin: 5px;
    }
    #output {
      margin-left: 10px;
      font-weight: bold;
    }
    #connectionsPanel {
      width: 100%;
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 10px;
      margin-top: 8px;
    }
    #edgeList {
      max-height: 140px;
      overflow: auto;
      background: #ffffff;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 6px;
    }
    #edgeList div { display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px dashed #eee; }
    #edgeList div:last-child { border-bottom: none; }
    #cityPanel {
      width: 100%;
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 10px;
      margin-top: 8px;
    }
    #cityList {
      max-height: 140px;
      overflow: auto;
      background: #ffffff;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 6px;
    }
    #cityList div { display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px dashed #eee; }
    #cityList div:last-child { border-bottom: none; }
  </style>
</head>
<body>
  <div id="controls">
    <label>From: 
      <select id="fromCity"></select>
    </label>
    <label>To: 
      <select id="toCity"></select>
    </label>
    <button id="findPath">Find Shortest Path</button>
    <button id="resetData">Reset Data</button>
    <span id="output"></span>

    <div id="connectionsPanel">
      <div>
        <strong>Manage Connections</strong><br/>
        <label>A: <select id="cityA"></select></label>
        <label>B: <select id="cityB"></select></label>
        <button id="addConn">Add Connection</button>
        <button id="resetConn">Reset Connections</button>
      </div>
      <div>
        <strong>Existing Connections</strong>
        <div id="edgeList" aria-live="polite"></div>
      </div>
    </div>
    <div id="cityPanel">
      <div>
        <strong>Add City</strong><br/>
        <label>Name: <input id="cityName" type="text" placeholder="City name" /></label>
        <label>Lat: <input id="cityLat" type="number" step="0.0001" placeholder="16.8661" /></label>
        <label>Lng: <input id="cityLng" type="number" step="0.0001" placeholder="96.1951" /></label>
        <button id="addCity">Add City</button>
      </div>
      <div>
        <strong>Existing Cities</strong>
        <div id="cityList" aria-live="polite"></div>
      </div>
    </div>
  </div>
  <div id="map"></div>

  <script>
    // --- Utility: Haversine distance (in km) ---
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371; // km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) ** 2 +
        Math.cos(lat1 * Math.PI / 180) *
        Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    // --- Default city data ---
    const defaultCities = [
      { name: "Yangon", lat: 16.8661, lng: 96.1951 },
      { name: "Mandalay", lat: 21.9588, lng: 96.0891 },
      { name: "Naypyidaw", lat: 19.7633, lng: 96.0785 },
      { name: "Bago", lat: 17.3369, lng: 96.4797 },
      { name: "Taunggyi", lat: 20.7892, lng: 97.0378 },
      { name: "Pathein", lat: 16.7792, lng: 94.7321 },
      { name: "Mawlamyine", lat: 16.4905, lng: 97.6283 }
    ];

    // --- Initialize or load from localStorage ---
    function getCities() {
      const data = localStorage.getItem("mm_cities");
      return data ? JSON.parse(data) : defaultCities;
    }
    function saveCities(cities) {
      localStorage.setItem("mm_cities", JSON.stringify(cities));
    }

    let cities = getCities();
    saveCities(cities);

    // --- Graph persistence ---
    function buildNearestNeighborGraph(cities) {
      const graph = {};
      for (let i = 0; i < cities.length; i++) {
        const a = cities[i];
        graph[a.name] = graph[a.name] || {};
        let best = null, bestD = Infinity;
        for (let j = 0; j < cities.length; j++) {
          if (i === j) continue;
          const b = cities[j];
          const d = haversine(a.lat, a.lng, b.lat, b.lng);
          if (d < bestD) { bestD = d; best = b; }
        }
        if (best) {
          graph[a.name][best.name] = bestD;
          graph[best.name] = graph[best.name] || {};
          graph[best.name][a.name] = bestD; // undirected
        }
      }
      return graph;
    }
    function getGraph(cities) {
      const data = localStorage.getItem("mm_graph");
      if (data) return JSON.parse(data);
      const g = buildNearestNeighborGraph(cities);
      localStorage.setItem("mm_graph", JSON.stringify(g));
      return g;
    }
    function saveGraph(graph) {
      localStorage.setItem("mm_graph", JSON.stringify(graph));
    }

    let graph = getGraph(cities);

    // --- Dijkstra algorithm ---
    function dijkstra(graph, start, end) {
      const distances = {};
      const prev = {};
      const pq = new Set(Object.keys(graph));

      for (const city in graph) {
        distances[city] = Infinity;
      }
      distances[start] = 0;

      while (pq.size > 0) {
        const current = [...pq].reduce((a, b) =>
          distances[a] < distances[b] ? a : b
        );
        pq.delete(current);

        if (current === end) break;

        for (const neighbor in graph[current]) {
          const alt = distances[current] + graph[current][neighbor];
          if (alt < distances[neighbor]) {
            distances[neighbor] = alt;
            prev[neighbor] = current;
          }
        }
      }

      // reconstruct path
      const path = [];
      let u = end;
      while (u) {
        path.unshift(u);
        u = prev[u];
      }

      return { distance: distances[end], path };
    }

    // --- Leaflet map setup ---
    const map = L.map("map").setView([19.7633, 96.0785], 6);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 8,
      attribution: "&copy; OpenStreetMap contributors",
    }).addTo(map);

    const markers = {};
    cities.forEach(city => {
      markers[city.name] = L.marker([city.lat, city.lng])
        .addTo(map)
        .bindPopup(city.name);
    });

    // Draw connections from graph (unique pairs)
    let edges = [];
    function getCityByName(n) { return cities.find(c => c.name === n); }
    function clearEdges() { edges.forEach(e => map.removeLayer(e)); edges = []; }
    function drawEdges() {
      clearEdges();
      const seen = new Set();
      for (const a in graph) {
        for (const b in graph[a]) {
          const key = [a, b].sort().join("|");
          if (seen.has(key)) continue;
          seen.add(key);
          const ca = getCityByName(a), cb = getCityByName(b);
          if (!ca || !cb) continue;
          const line = L.polyline([[ca.lat, ca.lng], [cb.lat, cb.lng]], {
            color: "#ccc",
            weight: 2,
          }).addTo(map);
          edges.push(line);
        }
      }
    }
    drawEdges();

    // --- Populate dropdowns ---
    const fromSel = document.getElementById("fromCity");
    const toSel = document.getElementById("toCity");
    const cityA = document.getElementById("cityA");
    const cityB = document.getElementById("cityB");
    const cityNameInput = document.getElementById('cityName');
    const cityLatInput = document.getElementById('cityLat');
    const cityLngInput = document.getElementById('cityLng');
    cities.forEach(c => {
      const opt1 = new Option(c.name, c.name);
      const opt2 = new Option(c.name, c.name);
      fromSel.add(opt1);
      toSel.add(opt2);
      cityA.add(new Option(c.name, c.name));
      cityB.add(new Option(c.name, c.name));
    });
    fromSel.value = "Yangon";
    toSel.value = "Mandalay";

    let currentPathLine = null;

    // --- Find Path button ---
    document.getElementById("findPath").onclick = () => {
      const from = fromSel.value;
      const to = toSel.value;
      const result = dijkstra(graph, from, to);
      const { distance, path } = result;
      document.getElementById("output").textContent =
        `Shortest path: ${path.join(" â†’ ")} (${distance.toFixed(2)} km)`;

      if (currentPathLine) map.removeLayer(currentPathLine);

      const coords = path.map(p => {
        const c = cities.find(x => x.name === p);
        return [c.lat, c.lng];
      });

      currentPathLine = L.polyline(coords, { color: "red", weight: 4 })
        .addTo(map);
      map.fitBounds(currentPathLine.getBounds());
    };

    // --- Reset data ---
    document.getElementById("resetData").onclick = () => {
      localStorage.removeItem("mm_cities");
      localStorage.removeItem("mm_graph");
      alert("Data reset. Reloading...");
      location.reload();
    };

    // --- Manage connections ---
    const edgeListEl = document.getElementById('edgeList');
    function renderEdgeList() {
      edgeListEl.innerHTML = '';
      const seen = new Set();
      for (const a in graph) {
        for (const b in graph[a]) {
          const key = [a,b].sort().join('|');
          if (seen.has(key)) continue; seen.add(key);
          const row = document.createElement('div');
          row.innerHTML = `<span>${a} 862 ${b}</span>`; // arrow-like separator
          const btn = document.createElement('button');
          btn.textContent = 'Remove';
          btn.onclick = () => {
            delete graph[a][b];
            if (graph[b]) delete graph[b][a];
            saveGraph(graph);
            drawEdges();
            renderEdgeList();
          };
          row.appendChild(btn);
          edgeListEl.appendChild(row);
        }
      }
      if (!edgeListEl.children.length) edgeListEl.textContent = 'No connections yet.';
    }
    renderEdgeList();

    document.getElementById('addConn').onclick = () => {
      const a = cityA.value; const b = cityB.value;
      if (!a || !b || a === b) return alert('Choose two different towns.');
      const ca = getCityByName(a); const cb = getCityByName(b);
      if (!ca || !cb) return alert('Invalid town selection.');
      const d = haversine(ca.lat, ca.lng, cb.lat, cb.lng);
      graph[a] = graph[a] || {}; graph[b] = graph[b] || {};
      graph[a][b] = d; graph[b][a] = d;
      saveGraph(graph);
      drawEdges();
      renderEdgeList();
    };

    document.getElementById('resetConn').onclick = () => {
      graph = buildNearestNeighborGraph(cities);
      saveGraph(graph);
      drawEdges();
      renderEdgeList();
    };

    // --- City Management ---
    const cityListEl = document.getElementById('cityList');
    function populateDropdowns() {
      [fromSel, toSel, cityA, cityB].forEach(sel => { while (sel.options.length) sel.remove(0); });
      cities.forEach(c => {
        fromSel.add(new Option(c.name, c.name));
        toSel.add(new Option(c.name, c.name));
        cityA.add(new Option(c.name, c.name));
        cityB.add(new Option(c.name, c.name));
      });
      if (!cities.find(c => c.name === fromSel.value) && cities[0]) fromSel.value = cities[0].name;
      if (!cities.find(c => c.name === toSel.value) && cities[1]) toSel.value = cities[1]?.name || cities[0]?.name;
    }
    function renderCityList() {
      cityListEl.innerHTML = '';
      cities.forEach(c => {
        const row = document.createElement('div');
        row.innerHTML = `<span>${c.name} (${Number(c.lat).toFixed(4)}, ${Number(c.lng).toFixed(4)})</span>`;
        const btn = document.createElement('button');
        btn.textContent = 'Remove';
        btn.onclick = () => {
          if (markers[c.name]) { map.removeLayer(markers[c.name]); delete markers[c.name]; }
          cities = cities.filter(x => x.name !== c.name);
          saveCities(cities);
          if (graph[c.name]) delete graph[c.name];
          for (const a in graph) { if (graph[a][c.name]) delete graph[a][c.name]; }
          saveGraph(graph);
          drawEdges();
          renderEdgeList();
          populateDropdowns();
          if (cities.length) map.setView([cities[0].lat, cities[0].lng], map.getZoom());
          renderCityList();
        };
        row.appendChild(btn);
        cityListEl.appendChild(row);
      });
      if (!cityListEl.children.length) cityListEl.textContent = 'No cities.';
    }
    renderCityList();

    document.getElementById('addCity').onclick = () => {
      const name = cityNameInput.value.trim();
      const lat = parseFloat(cityLatInput.value);
      const lng = parseFloat(cityLngInput.value);
      if (!name) return alert('Please enter a city name.');
      if (!isFinite(lat) || !isFinite(lng)) return alert('Please enter valid latitude and longitude.');
      if (lat < -90 || lat > 90 || lng < -180 || lng > 180) return alert('Latitude/Longitude out of range.');
      if (cities.find(c => c.name.toLowerCase() === name.toLowerCase())) return alert('City name already exists.');

      const city = { name, lat, lng };
      cities.push(city);
      saveCities(cities);

      markers[city.name] = L.marker([city.lat, city.lng]).addTo(map).bindPopup(city.name);

      let best = null, bestD = Infinity;
      for (const c of cities) {
        if (c.name === city.name) continue;
        const d = haversine(city.lat, city.lng, c.lat, c.lng);
        if (d < bestD) { bestD = d; best = c; }
      }
      graph[city.name] = graph[city.name] || {};
      if (best) {
        graph[city.name][best.name] = bestD;
        graph[best.name] = graph[best.name] || {};
        graph[best.name][city.name] = bestD;
      }
      saveGraph(graph);
      drawEdges();
      renderEdgeList();
      populateDropdowns();
      renderCityList();
      map.setView([city.lat, city.lng], map.getZoom());

      cityNameInput.value = '';
      cityLatInput.value = '';
      cityLngInput.value = '';
    };
  </script>
</body>
</html>
